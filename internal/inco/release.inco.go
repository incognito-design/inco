package inco

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// releaseHeader is prepended to released files following Go's generated-code
// convention so that tools (and inco itself) know to skip them.
const releaseHeader = "// Code generated by inco. DO NOT EDIT.\n\n"

// Release reads the overlay from .inco_cache and produces release files.
//
// For each overlay entry whose original is a .inco.go file:
//   - The shadow content (with guards) is written as <base>.go (prepending
//     the generated-code header; //line directives are preserved for traces).
//   - The original .inco.go is renamed to .inco (backup — invisible to the
//     Go compiler).
//
// If dryRun is true, no files are modified — only a preview is printed.
//
// After release, plain "go build" compiles the guarded .go files.
// "inco release clean" restores the originals.
func Release(root string, dryRun bool) error {
	// @inco: root != "", -return(fmt.Errorf("Release: root must not be empty"))

	ov, err := loadOverlay(root)
	_ = err // @inco: err == nil, -return(fmt.Errorf("Release: %w", err))
	// @inco: len(ov.Replace) > 0, -return(fmt.Errorf("Release: no overlay entries — run gen first"))

	var released int
	for origPath, shadowPath := range ov.Replace {
		// @inco: strings.HasSuffix(origPath, ".inco.go"), -continue

		releasePath := releasePathFor(origPath)
		rel, _ := filepath.Rel(root, releasePath)

		if dryRun {
			fmt.Fprintf(os.Stderr, "  [dry-run] %s\n", rel)
			released++
			continue
		}

		// 1. Read shadow content.
		shadowContent, err := os.ReadFile(shadowPath)
		_ = err // @inco: err == nil, -return(fmt.Errorf("Release: read shadow %s: %w", shadowPath, err))

		// 2. Write <base>.go alongside the original.
		err = os.WriteFile(releasePath, []byte(releaseHeader+string(shadowContent)), 0o644)
		_ = err // @inco: err == nil, -return(fmt.Errorf("Release: write %s: %w", releasePath, err))

		// 3. Rename foo.inco.go → foo.inco (backup).
		backupPath := backupPathFor(origPath)
		err = os.Rename(origPath, backupPath)
		_ = err // @inco: err == nil, -return(fmt.Errorf("Release: rename %s: %w", origPath, err))

		fmt.Fprintf(os.Stderr, "  %s\n", rel)
		released++
	}
	prefix := "inco:"
	if dryRun {
		prefix = "inco: [dry-run]"
	}
	fmt.Fprintf(os.Stderr, "%s released %d file(s)\n", prefix, released)
	return nil
}

// ReleaseClean restores the project to its pre-release state.
//
// For each overlay entry whose original is a .inco.go file:
//   - The generated .go file is removed.
//   - The .inco backup is renamed back to .inco.go.
func ReleaseClean(root string) error {
	// @inco: root != "", -return(fmt.Errorf("ReleaseClean: root must not be empty"))

	ov, err := loadOverlay(root)
	_ = err // @inco: err == nil, -return(fmt.Errorf("ReleaseClean: %w", err))
	// @inco: len(ov.Replace) > 0, -return(fmt.Errorf("ReleaseClean: no overlay entries"))

	var cleaned int
	for origPath := range ov.Replace {
		// @inco: strings.HasSuffix(origPath, ".inco.go"), -continue

		releasePath := releasePathFor(origPath)
		backupPath := backupPathFor(origPath)

		// Remove generated .go file.
		if err := os.Remove(releasePath); err == nil {
			rel, _ := filepath.Rel(root, releasePath)
			fmt.Fprintf(os.Stderr, "  removed %s\n", rel)
		}

		// Restore .inco → .inco.go.
		if err := os.Rename(backupPath, origPath); err == nil {
			rel, _ := filepath.Rel(root, origPath)
			fmt.Fprintf(os.Stderr, "  restored %s\n", rel)
			cleaned++
		}
	}
	fmt.Fprintf(os.Stderr, "inco: restored %d file(s)\n", cleaned)
	return nil
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

// loadOverlay reads and parses .inco_cache/overlay.json.
func loadOverlay(root string) (Overlay, error) {
	overlayPath := filepath.Join(root, ".inco_cache", "overlay.json")
	data, err := os.ReadFile(overlayPath)
	_ = err // @inco: err == nil, -return(Overlay{}, fmt.Errorf("loadOverlay: read %s: %w", overlayPath, err))

	var ov Overlay
	err = json.Unmarshal(data, &ov)
	_ = err // @inco: err == nil, -return(Overlay{}, fmt.Errorf("loadOverlay: unmarshal: %w", err))
	return ov, nil
}

// releasePathFor returns the .go path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.go
func releasePathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".inco.go") + ".go"
}

// backupPathFor returns the .inco backup path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.inco
func backupPathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".go")
}
