package inco

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// releaseHeader is prepended to released files following Go's generated-code
// convention so that tools (and inco itself) know to skip them.
const releaseHeader = "// Code generated by inco. DO NOT EDIT.\n\n"

// releaseBuildTag is the build constraint added to released guard files.
const releaseBuildTag = "//go:build inco\n\n"

// excludeBuildTag is the build constraint added to original source files
// so they are excluded when building with -tags inco.
const excludeBuildTag = "//go:build !inco\n\n"

// Release reads the overlay from .inco_cache and copies shadow files into
// the project source tree with build-tag isolation.
//
// For each overlay entry:
//   - The original file gets "//go:build !inco" prepended (if not already present).
//   - The shadow content is saved as <base>_inco.go with "//go:build inco" in
//     the same directory as the original.
//
// After release, "go build -tags inco" compiles the guarded sources and
// "go build" (without the tag) compiles the originals — no -overlay needed.
func Release(root string) {
	// @require root != "" panic("Release: root must not be empty")

	ov := loadOverlay(root)
	// @require len(ov.Replace) > 0 panic("Release: no overlay entries — run gen first")

	var released int
	for origPath, shadowPath := range ov.Replace {
		// 1. Read shadow content.
		shadowContent, _ := os.ReadFile(shadowPath) // @must

		// 2. Build the released file: strip any stale !inco tag from the
		//    shadow (can appear if release was run before gen), then prepend
		//    the generated-code header and the inco build tag.
		shadowStr := string(shadowContent)
		shadowStr = strings.TrimPrefix(shadowStr, excludeBuildTag)
		tagged := releaseHeader + releaseBuildTag + shadowStr

		// 3. Write <base>_inco.go alongside the original.
		releasePath := releasePathFor(origPath)
		_ = os.WriteFile(releasePath, []byte(tagged), 0o644) // @must

		// 4. Add //go:build !inco to the original if not already present.
		origContent, _ := os.ReadFile(origPath) // @must
		if !strings.HasPrefix(string(origContent), "//go:build !inco") {
			taggedOrig := excludeBuildTag + string(origContent)
			_ = os.WriteFile(origPath, []byte(taggedOrig), 0o644) // @must
		}

		rel, _ := filepath.Rel(root, releasePath)
		fmt.Fprintf(os.Stderr, "  %s\n", rel)
		released++
	}
	fmt.Fprintf(os.Stderr, "inco: released %d file(s) — build with: go build -tags inco\n", released)
}

// ReleaseClean removes released _inco.go files and strips the //go:build !inco
// tag from original sources, reverting the project to its pre-release state.
func ReleaseClean(root string) {
	// @require root != "" panic("ReleaseClean: root must not be empty")

	ov := loadOverlay(root)
	// @require len(ov.Replace) > 0 panic("ReleaseClean: no overlay entries")

	var cleaned int
	for origPath := range ov.Replace {
		releasePath := releasePathFor(origPath)

		// Remove the _inco.go file.
		if err := os.Remove(releasePath); err == nil {
			rel, _ := filepath.Rel(root, releasePath)
			fmt.Fprintf(os.Stderr, "  removed %s\n", rel)
			cleaned++
		}

		// Strip //go:build !inco from the original.
		origContent, err := os.ReadFile(origPath)
		if err != nil {
			continue
		}
		s := string(origContent)
		if strings.HasPrefix(s, excludeBuildTag) {
			s = strings.TrimPrefix(s, excludeBuildTag)
			_ = os.WriteFile(origPath, []byte(s), 0o644) // @must
		}
	}
	fmt.Fprintf(os.Stderr, "inco: cleaned %d released file(s)\n", cleaned)
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

// loadOverlay reads and parses .inco_cache/overlay.json.
func loadOverlay(root string) Overlay {
	overlayPath := filepath.Join(root, ".inco_cache", "overlay.json")
	data, _ := os.ReadFile(overlayPath) // @must

	var ov Overlay
	_ = json.Unmarshal(data, &ov) // @must
	return ov
}

// releasePathFor returns the _inco.go path for an original source file.
//
//	/a/b/foo.go → /a/b/foo_inco.go
func releasePathFor(origPath string) string {
	dir := filepath.Dir(origPath)
	base := strings.TrimSuffix(filepath.Base(origPath), ".go")
	return filepath.Join(dir, base+"_inco.go")
}
