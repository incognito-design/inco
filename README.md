# Inco

Invisible constraints. Invincible code.

Inco is a compile-time assertion engine for Go. Write contract directives as plain comments; they are transformed into runtime guards in shadow files, wired in via `go build -overlay`. Your source stays untouched.

## Philosophy

Business logic should be pure. Defensive noise — `if x == nil`, `if err != nil` — belongs in the shadow, not in your source.

Write the intent; Inco generates the shield.

### `if` is for logic, not for guarding

In an Inco codebase, `if` should express **logic flow** — branching on business conditions, selecting behavior. Not for:

- **Nil guards** → `// @inco: ptr != nil`
- **Value validation** → `// @inco: x > 0`
- **Range checks** → `// @inco: i < len(s)`

When every defensive check is a directive, the remaining `if` statements carry **real** semantic weight — genuine decisions, not boilerplate.

## Directive Syntax

One directive, multiple actions:

```
// @inco: <expr>
// @inco: <expr>, -panic("msg")
// @inco: <expr>, -return(values...)
// @inco: <expr>, -continue
// @inco: <expr>, -break
```

The default action is `-panic` with an auto-generated message.

### Examples

```go
func Transfer(from *Account, to *Account, amount int) {
    // @inco: from != nil
    // @inco: to != nil
    // @inco: amount > 0, -panic("amount must be positive")

    // ...
}
```

```go
func Parse(s string) (int, error) {
    // @inco: len(s) > 0, -return(0, fmt.Errorf("empty"))
    return len(s), nil
}
```

```go
func PrintPositive(nums []int) {
    for _, n := range nums {
        // @inco: n > 0, -continue
        fmt.Println(n)
    }
}
```

### Actions

| Action | Syntax | Meaning |
|--------|--------|---------|
| panic (default) | `// @inco: <expr>` | Panic with auto message |
| panic (custom) | `// @inco: <expr>, -panic("msg")` | Panic with custom message |
| return | `// @inco: <expr>, -return(vals...)` | Return specified values |
| return (bare) | `// @inco: <expr>, -return` | Bare return |
| continue | `// @inco: <expr>, -continue` | Continue enclosing loop |
| break | `// @inco: <expr>, -break` | Break enclosing loop |

### Generated Output

After `inco gen`, the above becomes a shadow file in `.inco_cache/`:

```go
func Transfer(from *Account, to *Account, amount int) {
    if !(from != nil) {
        panic("inco violation: from != nil (at transfer.go:2)")
    }
    if !(to != nil) {
        panic("inco violation: to != nil (at transfer.go:3)")
    }
    if !(amount > 0) {
        panic("amount must be positive")
    }

    // ...
}
```

Source files remain untouched. Shadow files live in `.inco_cache/` and are wired in via `go build -overlay`.

## Generics

Works with generic functions and types:

```go
func Clamp[N Number](val, lo, hi N) N {
    // @inco: lo <= hi
    if val < lo {
        return lo
    }
    if val > hi {
        return hi
    }
    return val
}

func NewPair[K comparable, V any](key K, value V) Pair[K, V] {
    // @inco: key != *new(K), -panic("key must not be zero")
    return Pair[K, V]{Key: key, Value: value}
}
```

## Auto-Import

When directive arguments reference standard library packages (e.g. `fmt.Sprintf`, `errors.New`), Inco automatically adds the corresponding import to the shadow file via `astutil.AddImport`. No manual import management needed.

## Usage

```bash
# Install
go install github.com/incognito-design/inco/cmd/inco@latest

# Generate overlay
inco gen [dir]

# Build / Test / Run with contracts enforced
inco build ./...
inco test ./...
inco run .

# Release: bake guards into source tree (no overlay needed)
inco release [dir]

# Revert release
inco release clean [dir]

# Contract coverage audit
inco audit [dir]

# Clean cache
inco clean [dir]
```

## Release Mode

`inco release` bakes guards into your source tree — no overlay, no build tags, no `inco` tool needed at build time.

### Convention: `.inco.go` files

Name source files that contain directives with a `.inco.go` extension:

```
foo.inco.go   ← source with @inco: directives
```

`inco gen` and `inco build` treat `.inco.go` files exactly like `.go` files (they end in `.go`, so the scanner picks them up).

### Release workflow

```bash
inco release .
```

For each `.inco.go` file in the overlay:

1. **Generate** `foo.go` — shadow content with guards injected (the `// Code generated by inco. DO NOT EDIT.` header is prepended)
2. **Backup** `foo.inco.go` → `foo.inco` — renamed so the Go compiler ignores it

After release:

```bash
go build ./...    # compiles foo.go (with guards) — no overlay, no inco needed
```

### Restore

```bash
inco release clean .
```

This removes each generated `foo.go` and restores `foo.inco` → `foo.inco.go`.

### When to use

- **Distribution**: ship a self-contained project with contracts baked in
- **CI/CD**: build with guards without installing `inco`
- **One-click restore**: `inco release clean` brings you back to development mode

## Build from Source

```bash
# Two-stage build:
make build
# Stage 0: plain go build → bin/inco-bootstrap (no contracts)
# Stage 1: bootstrap generates overlay → compiles with contracts → bin/inco

# Other targets:
make test       # Run tests with contracts enforced
make clean      # Remove .inco_cache/ and bin/
make install    # Install to $GOPATH/bin
```

## Audit

`inco audit` scans your codebase and reports:

- **@inco: coverage**: percentage of functions guarded by at least one `@inco:` directive
- **Directive vs if ratio**: total `@inco:` directives compared to native `if` statements
- **Per-file breakdown**: directive and `if` counts per file
- **Unguarded functions**: list of functions without any `@inco:` directive

```
$ inco audit .
inco audit — contract coverage report
======================================

  Files scanned:  10
  Functions:      62

@inco: coverage:
  With @inco::     10 / 62  (16.1%)
  Without @inco::  52 / 62  (83.9%)

Directive vs if:
  @inco::           18
  ─────────────────────
  Total directives:   18
  Native if stmts:    122
  Directive/if ratio: 0.15

Per-file breakdown:
  File                        @inco:  if  funcs  guarded
  ──────────────────────────  ──────  ──  ─────  ───────
  example/demo.inco.go             5   0      3        3
  example/edge_cases.inco.go       6   1      5        3
  internal/inco/engine.inco.go     6  45     19        4
  ...

Functions without @inco: (46):
  cmd/inco/main.inco.go:24  main
  internal/inco/engine.inco.go:52  Run
  ...
```

The goal: drive `@inco:` coverage up and the directive/if ratio toward 1.0+, meaning most defensive checks live in directives rather than manual `if` statements.

## How It Works

1. `inco gen` scans all `.go` files for `// @inco:` comments
2. Parses directives and generates shadow files with injected `if`-blocks in `.inco_cache/`
3. Injects `//line` directives so panic stack traces point back to **original** source lines
4. Produces `overlay.json` for `go build -overlay`
5. Source files remain untouched — zero invasion

## Project Structure

```
cmd/inco/           CLI: gen, build, test, run, audit, release, clean
internal/inco/      Core engine:
  audit.inco.go       Contract coverage auditing
  directive.inco.go   Directive parsing (@inco:)
  engine.inco.go      AST processing, code generation, overlay I/O
  release.inco.go     Release mode: bake guards into source
  types.inco.go       Core types (Directive, ActionKind, Overlay, Recover)
example/            Demo files:
  demo.inco.go        @inco: basics
  transfer.inco.go    Multiple @inco: with panic
  edge_cases.inco.go  Closures, actions, edge cases
  generics.inco.go    Type parameters, generic containers
```

## Design

- **Zero-invasive**: Plain Go comments — no custom syntax, no broken IDE support
- **Fail-fast**: panic by default — or return, continue, break as needed
- **Zero-overhead option**: Strip directives in production, or keep for fail-fast
- **Cache-friendly**: Content-hash (SHA-256) based shadow filenames for stable build cache
- **Source-mapped**: `//line` directives preserve original file:line in stack traces
- **Auto-import**: Standard library references in directive args are auto-imported

## License

MIT
